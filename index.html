<!DOCTYPE html>
<html>
  <head>
    <title>Iron Router Guide</title>
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,500,700,300' rel='stylesheet' type='text/css'>
    <link href="stylesheets/basscss.min.css" rel="stylesheet">
    <link href="stylesheets/prism.css" rel="stylesheet" />
    <link href="stylesheets/style.css" rel="stylesheet">
  </head>
  <body>
    <div class="container">
      <a class="forkme_banner" href="https://github.com/EventedMind/iron-router">View on GitHub</a>
      <h1 class="logo mx-auto mt5">
        <div class="sm-show center">
          <img src="images/iron-router-logo.png">
        </div>
        <div class="sm-hide center">
          <img src="images/iron-router-logo-mobile.png">
        </div>
      </h1>
      <h2 class="page-title center">Guide</h2>
      <div class="content">
        <div class="clearfix downloads-container">
          <div class="downloads right">
            <a class="zip_download_link" href="https://github.com/EventedMind/iron-router/zipball/master">Download this project as a .zip file</a>
            <a class="tar_download_link" href="https://github.com/EventedMind/iron-router/tarball/master">Download this project as a tar.gz file</a>
          </div>
        </div>
        <h1 id="iron-router">Iron.Router</h1>
<p>A router that works on the server and the browser, designed specifically for
<a href="https://github.com/meteor/meteor">Meteor</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<p>You can install iron:router using Meteor&#39;s package management system:</p>
<pre><code class="lang-bash">&gt; meteor add iron:router
</code></pre>
<p>To update iron:router to the latest version you can use the <code>meteor update</code>
command:</p>
<pre><code class="lang-bash">&gt; meteor update iron:router
</code></pre>
<p>Start by creating a route in your JavaScript file. By default, routes are
created for the client and will run in the browser.</p>
<pre><code class="lang-javascript">Router.route(&#39;/&#39;, function () {
  this.render(&#39;Home&#39;);
});
</code></pre>
<p>When the user navigates to the url &quot;/&quot;, the route above will render the template
named &quot;Home&quot; onto the page.</p>
<pre><code class="lang-javascript">Router.route(&#39;/items&#39;);
</code></pre>
<p>This second route will automatically render a template named &quot;Items&quot; or &quot;items&quot;
to the page. In simple cases like this, you don&#39;t even need to provide a route
function.</p>
<p>So far, we&#39;ve only created routes that will be run directly in the browser. But
we can also create server routes. These hook directly into the HTTP request and
are used to implement REST endpoints.</p>
<pre><code class="lang-javascript">Router.route(&#39;/item&#39;, function () {
  var req = this.request;
  var res = this.response;
  res.end(&#39;hello from the server\n&#39;);
}, {where: &#39;server&#39;});
</code></pre>
<p>The <code>where: &#39;server&#39;</code> option tells the Router this is a server side route.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#concepts">Concepts</a><ul>
<li><a href="#server-only">Server Only</a></li>
<li><a href="#client-only">Client Only</a></li>
<li><a href="#client-and-server">Client and Server</a></li>
<li><a href="#reactivity">Reactivity</a></li>
</ul>
</li>
<li><a href="#route-parameters">Route Parameters</a></li>
<li><a href="#rendering-templates">Rendering Templates</a></li>
<li><a href="#rendering-templates-with-data">Rendering Templates with Data</a></li>
<li><a href="#layouts">Layouts</a><ul>
<li><a href="#rendering-templates-into-regions-with-javascript">Rendering Templates into Regions with JavaScript</a></li>
<li><a href="#setting-region-data-contexts">Setting Region Data Contexts</a></li>
<li><a href="#rendering-templates-into-regions-using-contentfor">Rendering Templates into Regions using contentFor</a></li>
</ul>
</li>
<li><a href="#client-navigation">Client Navigation</a><ul>
<li><a href="#using-links">Using Links</a></li>
<li><a href="#using-javascript">Using JavaScript</a></li>
<li><a href="#using-redirects">Using Redirects</a></li>
<li><a href="#using-links-to-server-routes">Using Links to Server Routes</a></li>
</ul>
</li>
<li><a href="#named-routes">Named Routes</a><ul>
<li><a href="#getting-the-current-route">Getting the Current Route</a></li>
</ul>
</li>
<li><a href="#template-lookup">Template Lookup</a></li>
<li><a href="#path-and-link-template-helpers">Path and Link Template Helpers</a><ul>
<li><a href="#pathfor">pathFor</a></li>
<li><a href="#urlFor">urlFor</a></li>
<li><a href="#linkTo">linkTo</a></li>
</ul>
</li>
<li><a href="#route-options">Route Options</a><ul>
<li><a href="#route-specific-options">Route Specific Options</a></li>
<li><a href="#global-default-options">Global Default Options</a></li>
</ul>
</li>
<li><a href="#subscriptions">Subscriptions</a><ul>
<li><a href="#wait-and-ready">Wait and Ready</a></li>
<li><a href="#the-subscriptions-option">The subscriptions Option</a></li>
<li><a href="#the-waiton-option">The waitOn Option</a></li>
</ul>
</li>
<li><a href="#server-routing">Server Routing</a><ul>
<li><a href="#creating-routes">Creating Routes</a></li>
<li><a href="#restful-routes">Restful Routes</a></li>
<li><a href="#404s-and-client-vs-server-routes">404s and Client vs Server Routes</a></li>
<li><a href="#server-middleware-and-connect">Server Middleware and Connect</a></li>
</ul>
</li>
<li><a href="#plugins">Plugins</a><ul>
<li><a href="#creating-plugins">Creating Plugins</a></li>
</ul>
</li>
<li><a href="#hooks">Hooks</a><ul>
<li><a href="#using-hooks">Using Hooks</a></li>
<li><a href="#applying-hooks-to-specific-routes">Applying Hooks to Specific Routes</a></li>
<li><a href="#using-the-iron-router-hooks-namespace">Using the Iron.Router.hooks Namespace</a></li>
<li><a href="#available-hook-methods">Available Hook Methods</a></li>
</ul>
</li>
<li><a href="#route-controllers">Route Controllers</a><ul>
<li><a href="#creating-route-controllers">Creating Route Controllers</a> </li>
<li><a href="#inheriting-from-route-controllers">Inheriting from Route Controllers</a> </li>
<li><a href="#accessing-the-current-route-controller">Accessing the Current Route Controller</a></li>
<li><a href="#setting-reactive-state-variables">Setting Reactive State Variables</a></li>
<li><a href="#getting-reactive-state-variables">Getting Reactive State Variables</a></li>
</ul>
</li>
<li><a href="#custom-router-rendering">Custom Router Rendering</a></li>
<li><a href="#legacy-browser-support">Legacy Browser Support</a></li>
</ul>
<h2 id="concepts">Concepts</h2>
<h3 id="server-only">Server Only</h3>
<p>In a typical Web app, you make an http request to a server at a particular url,
like &quot;/items/5&quot;, and a router on the server decides which function to invoke for
that particular route. The function will most likely send some html back to the
browser and close the connection.</p>
<h3 id="client-only">Client Only</h3>
<p>In some more modern Web apps you&#39;ll use a &quot;client side&quot; router like pagejs or
Backbone router. These routers run in the browser, and let you navigate around
an application without making trips to the server by taking advantage of browser
HTML5 features like pushState or url hash fragments. </p>
<h3 id="client-and-server">Client and Server</h3>
<p>Iron.Router runs on the client <em>and</em> the server. You can define a route that
only should run on the server, or a route that should only run on the client.
Most of the time you&#39;ll create routes on the client. This makes your app really
fast once it&#39;s loaded, because as you navigate around the application, you don&#39;t
need to load an entirely new html page.</p>
<p>The router is <em>aware</em> of all the routes on the client and the server. This means
you can click a link that takes you to a server route, or it might take you to a
client route. It also means that on the server, if there is no client route
defined, we can send a 404 response to the client instead of loading up the
Meteor application.</p>
<h3 id="reactivity">Reactivity</h3>
<p>Your route functions and most hooks are run in a reactive computation. This
means they will rerun automatically if a reactive data source changes. For
example, if you call <code>Meteor.user()</code> inside of your route function, your route
function will rerun each time the value of <code>Meteor.user()</code> changes.</p>
<h2 id="route-parameters">Route Parameters</h2>
<p>Routes can have variable parameters. For example, you can create one route to
show any post with an id. The <code>id</code> is variable depending on the post you want to
see such as &quot;/posts/1&quot; or &quot;/posts/2&quot;. To declare a named parameter in your route
use the <code>:</code> syntax in the url followed by the parameter name. When a user goes
to that url, the actual value of the parameter will be stored as a property on
<code>this.params</code> in your route function.</p>
<p>In this example we have a route parameter named <code>_id</code>. If we navigate to the
<code>/post/5</code> url in our browser, inside of the route function we can get the actual
value of the <code>_id</code> from <code>this.params._id</code>. In this case <code>this.params._id =&gt; 5</code>.</p>
<pre><code class="lang-javascript">// given a url like &quot;/post/5&quot;
Router.route(&#39;/post/:_id&#39;, function () {
  var params = this.params; // { _id: &quot;5&quot; }
  var id = params._id; // &quot;5&quot;
});
</code></pre>
<p>You can have multiple route parameters. In this example, we have an <code>_id</code>
parameter and a <code>commentId</code> parameter. If you navigate to the url
<code>/post/5/comments/100</code> then inside your route function <code>this.params._id =&gt; 5</code>
and <code>this.params.commentId =&gt; 100</code>.</p>
<pre><code class="lang-javascript">// given a url like &quot;/post/5/comments/100&quot;
Router.route(&#39;/post/:_id/comments/:commentId&#39;, function () {
  var id = this.params._id; // &quot;5&quot;
  var commentId = this.params.commentId; // &quot;100&quot;
});
</code></pre>
<p>If there is a query string or hash fragment in the url, you can access those
using the <code>query</code> and <code>hash</code> properties of the <code>this.params</code> object.</p>
<pre><code class="lang-javascript">// given the url: &quot;/post/5?q=s#hashFrag&quot;
Router.route(&#39;/post/:_id&#39;, function () {
  var id = this.params._id;
  var query = this.params.query;

  // query.q -&gt; &quot;s&quot;
  var hash = this.params.hash; // &quot;hashFrag&quot;
});
</code></pre>
<p><strong>Note</strong>: If you want to rerun a function when the hash changes you can do this:</p>
<pre><code class="lang-javascript">// get a handle for the controller.
// in a template helper this would be
// var controller = Iron.controller();
var controller = this;

// reactive getParams method which will invalidate the comp if any part of the params change
// including the hash.
var params = controller.getParams();
</code></pre>
<p>By default the router will follow normal browser behavior. If you click a link with a hash frag it will scroll to an element with that id. If you want to use <code>controller.getParams()</code> you can put that in either your own autorun if you want to do something procedural, or in a helper.</p>
<h2 id="rendering-templates">Rendering Templates</h2>
<p>Usually we want to render a template when the user goes to a particular url. For
example, we might want to render the template named <code>Post</code> when the user
navigates to the url <code>/posts/1</code>.</p>
<pre><code class="lang-handlebars">&lt;template name=&quot;Post&quot;&gt;
  &lt;h1&gt;Post: {{title}}&lt;/h1&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="lang-javascript">Router.route(&#39;/post/:_id&#39;, function () {
  this.render(&#39;Post&#39;);
});
</code></pre>
<p>We can render a template by calling the <code>render</code> method inside of our route
function. The <code>render</code> method takes the name of a template as its first
parameter.</p>
<h2 id="rendering-templates-with-data">Rendering Templates with Data</h2>
<p>In the above example the <code>title</code> value is not defined. We could create a helper
on the Post template called <code>title</code> or we can set a data context for the
template directly from our route function. To do that, we provide a <code>data</code>
option as a second parameter to the <code>render</code> call.</p>
<pre><code class="lang-javascript">Router.route(&#39;/post/:_id&#39;, function () {
  this.render(&#39;Post&#39;, {
    data: function () {
      return Posts.findOne({_id: this.params._id});
    }
  });
});
</code></pre>
<h2 id="layouts">Layouts</h2>
<p>Layouts allow you to reuse a common look and feel in multiple pages in your
application so you don&#39;t have to duplicate the html and logic on every single
page template.</p>
<p>Layouts are just templates. But, inside of a layout you can use a special helper
called <code>yield</code>. You can think of <code>yield</code> as a placeholder for content. The
placeholder is called a <em>region.</em> The content will be &quot;injected&quot; into the
region when we actually run our route.  This lets us reuse the layout on many
different pages, only changing the content of the <em>yield regions</em>.</p>
<pre><code class="lang-handlebars">&lt;template name=&quot;ApplicationLayout&quot;&gt;
  &lt;header&gt;
    &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;/header&gt;

  &lt;aside&gt;
    {{&gt; yield &quot;aside&quot;}}
  &lt;/aside&gt;

  &lt;article&gt;
    {{&gt; yield}}
  &lt;/article&gt;

  &lt;footer&gt;
    {{&gt; yield &quot;footer&quot;}}
  &lt;/footer&gt;
&lt;/template&gt;
</code></pre>
<p>We can tell our route function which layout template to use by calling the
<code>layout</code> method.</p>
<pre><code class="lang-javascript">Router.route(&#39;/post/:_id&#39;, function () {
  this.layout(&#39;ApplicationLayout&#39;);
});
</code></pre>
<p>If you want to use a default layout template for all routes you can configure a
global Router option.</p>
<pre><code class="lang-javascript">Router.configure({
  layoutTemplate: &#39;ApplicationLayout&#39;
});
</code></pre>
<h3 id="rendering-templates-into-regions-with-javascript">Rendering Templates into Regions with JavaScript</h3>
<p>Inside of our route function we can tell the router which templates to render
into each region. </p>
<pre><code class="lang-handlebars">&lt;template name=&quot;Post&quot;&gt;
  &lt;p&gt;
    {{post_content}}
  &lt;/p&gt;
&lt;/template&gt;

&lt;template name=&quot;PostFooter&quot;&gt;
  Some post specific footer content.
&lt;/template&gt;

&lt;template name=&quot;PostAside&quot;&gt;
  Some post specific aside content.
&lt;/template&gt;
</code></pre>
<p>Let&#39;s say we&#39;re using the <code>ApplicationLayout</code> and we want to put the templates
defined above into their respective regions for the <code>/post/:_id</code> route. We can
do this directly in our route function using the <code>to</code> option of the <code>render</code>
method.</p>
<pre><code class="lang-javascript">Router.route(&#39;/post/:_id&#39;, function () {
  // use the template named ApplicationLayout for our layout
  this.layout(&#39;ApplicationLayout&#39;);

  // render the Post template into the &quot;main&quot; region
  // {{&gt; yield}}
  this.render(&#39;Post&#39;);

  // render the PostAside template into the yield region named &quot;aside&quot; 
  // {{&gt; yield &quot;aside&quot;}}
  this.render(&#39;PostAside&#39;, {to: &#39;aside&#39;});

  // render the PostFooter template into the yield region named &quot;footer&quot; 
  // {{&gt; yield &quot;footer&quot;}}
  this.render(&#39;PostFooter&#39;, {to: &#39;footer&#39;});
});
</code></pre>
<h3 id="setting-region-data-contexts">Setting Region Data Contexts</h3>
<p>You can set the data contexts for regions by providing a <code>data</code> option to the
<code>render</code> method. You can also set a data context for the entire layout.</p>
<pre><code class="lang-javascript">Router.route(&#39;/post/:_id&#39;, function () {
  this.layout(&#39;ApplicationLayout&#39;, {
    data: function () { return Posts.findOne({_id: this.params._id}) }
  });

  this.render(&#39;Post&#39;, {
    // we don&#39;t really need this since we set the data context for the
    // the entire layout above. But this demonstrates how you can set
    // a new data context for each specific region.
    data: function () { return Posts.findOne({_id: this.params._id})
  });

  this.render(&#39;PostAside&#39;, {
    to: &#39;aside&#39;,
    data: function () { return Posts.findOne({_id: this.params._id})
  });

  this.render(&#39;PostFooter&#39;, {
    to: &#39;footer&#39;,
    data: function () { return Posts.findOne({_id: this.params._id})
  });
});
</code></pre>
<h3 id="rendering-templates-into-regions-using-contentfor">Rendering Templates into Regions using contentFor</h3>
<p>Rendering templates into region from our route function can be useful,
especially if we need to run some custom logic or if the template names are
dynamic. But often an easier way to provide content for a region is to use the
<code>contentFor</code> helper directly from our main template. Let&#39;s say we&#39;re using the
same <code>ApplicationLayout</code> from the previous example. But this time, instead of
defining a new template for each region, we&#39;ll provide the content <em>inline</em> in
our <code>Post</code> template.</p>
<pre><code class="lang-handlebars">&lt;template name=&quot;Post&quot;&gt;
  &lt;p&gt;
    {{post_content}}
  &lt;/p&gt;

  {{#contentFor &quot;aside&quot;}}
    Some post specific aside content.
  {{/contentFor}}

  {{#contentFor &quot;footer&quot;}}
    Some post specific footer content.
  {{/contentFor}}
&lt;/template&gt;
</code></pre>
<p>Now we can simply specify our layout and render the <code>Post</code> template instead of
each individual region.</p>
<pre><code class="lang-javascript">Router.route(&#39;/post/:_id&#39;, function () {
  this.layout(&#39;ApplicationLayout&#39;, {
    data: function () { return Posts.findOne({_id: this.params._id}) }
  });

  // this time just render the template named &quot;Post&quot; into the main
  // region
  this.render(&#39;Post&#39;);
});
</code></pre>
<p>You can even provide a template option to the <code>contentFor</code> helper instead of
providing in-line block content.</p>
<pre><code class="lang-handlebars">&lt;template name=&quot;Post&quot;&gt;
  &lt;p&gt;
    {{post_content}}
  &lt;/p&gt;

  {{&gt; contentFor region=&quot;aside&quot; template=&quot;PostAside&quot;}}

  {{&gt; contentFor region=&quot;footer&quot; template=&quot;PostFooter&quot;}}
&lt;/template&gt;
</code></pre>
<h2 id="client-navigation">Client Navigation</h2>
<p>Most of the time users of your application will navigate around the app inside
the browser instead of making new requests to the server for each page. There
are a few ways to navigate around the application.</p>
<h3 id="using-links">Using Links</h3>
<p>Users can navigate around the application by clicking links. Let&#39;s say we have a
layout with some navigation links.</p>
<pre><code class="lang-handlebars">&lt;template name=&quot;ApplicationLayout&quot;&gt;
  &lt;nav&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;
      &lt;/li&gt;

      &lt;li&gt;
        &lt;a href=&quot;/one&quot;&gt;Page One&lt;/a&gt;
      &lt;/li&gt;

      &lt;li&gt;
        &lt;a href=&quot;/two&quot;&gt;Page Two&lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/nav&gt;

  &lt;article&gt;
    {{&gt; yield}}
  &lt;/article&gt;
&lt;/template&gt;

&lt;template name=&quot;Home&quot;&gt;
  Home
&lt;/template&gt;

&lt;template name=&quot;PageOne&quot;&gt;
  Page One
&lt;/template&gt;

&lt;template name=&quot;PageTwo&quot;&gt;
  Page Two
&lt;/template&gt;
</code></pre>
<p>Next, we&#39;ll define some routes for these pages.</p>
<pre><code class="lang-javascript">Router.route(&#39;/&#39;, function () {
  this.render(&#39;Home&#39;);
});

Router.route(&#39;/one&#39;, function () {
  this.render(&#39;PageOne&#39;);
});

Router.route(&#39;/two&#39;, function () {
  this.render(&#39;PageTwo&#39;);
});
</code></pre>
<p>When the application first loads at the root url <code>/</code> the first route will run
and the template named &quot;Home&quot; will be rendered to the page.</p>
<p>If the user clicks the <code>Page One</code> link, the url in the browser will change to
&#39;/one&#39; and the second route will run, rendering the &#39;PageOne&#39; template.</p>
<p>Likewise, if the user clicks the <code>Page Two</code> link, the url in the browser will
change to &#39;/two&#39; and the third route will run, rendering the &#39;PageTwo&#39; template.</p>
<p>Even though the url is changing in the browser, since these are client-side
routes, the browser doesn&#39;t need to make requests to the server. </p>
<h3 id="using-javascript">Using JavaScript</h3>
<p>You can navigate to a given url, or even a route name, from JavaScript using the
<code>Router.go</code> method. Let&#39;s say we&#39;ve defined a click event handler for a button.</p>
<pre><code class="lang-handlebars">&lt;template name=&quot;MyButton&quot;&gt;
  &lt;button id=&quot;clickme&quot;&gt;Go to Page One&lt;/button&gt;
&lt;/template&gt;
</code></pre>
<p>In our click event handler we can tell the router to go to the <code>/one</code> url.</p>
<pre><code class="lang-javascript">Template.MyButton.events({
  &#39;click #clickme&#39;: function () {
    Router.go(&#39;/one&#39;);
  }
});
</code></pre>
<p>This will change the browser&#39;s url to <code>/one</code> and run the corresponding route.</p>
<h3 id="using-redirects">Using Redirects</h3>
<p>You can redirect from one route to another from inside a route function by using
the <code>redirect</code> method inside your route function.</p>
<pre><code class="lang-javascript">Router.route(&#39;/one&#39;, function () {
  this.redirect(&#39;/two&#39;);
});

Router.route(&#39;/two&#39;, function () {
  this.render(&#39;PageTwo&#39;);
});
</code></pre>
<h3 id="using-links-to-server-routes">Using Links to Server Routes</h3>
<p>Let&#39;s say you have a server route that you&#39;d like to link to. For example, a
file download route which <em>has</em> to go to the server.</p>
<pre><code class="lang-javascript">Router.route(&#39;/download/:filename&#39;, function () {
  this.response.end(&#39;some file content\n&#39;);
}, {where: &#39;server&#39;});
</code></pre>
<p>Now, in our html we&#39;ll have a link to download a particular file.</p>
<pre><code class="lang-handlebars">&lt;a href=&quot;/download/myfilename&quot;&gt;Download File&lt;/a&gt;
</code></pre>
<p>When a user clicks on the <code>Download File</code> link, the router will send you to the
server and run the server-side route.</p>
<h2 id="named-routes">Named Routes</h2>
<p>Routes can have names that can be used to refer to the route. If you don&#39;t give
it a name, the router will guess its name based on the path. But you can provide
a name explicitly using the <code>name</code> option.</p>
<pre><code class="lang-javascript">Router.route(&#39;/posts/:_id&#39;, function () {
  this.render(&#39;Post&#39;);
}, {
  name: &#39;post.show&#39;
});
</code></pre>
<p>Now that we&#39;ve named our route, we can get access to the route object if needed
like this:</p>
<pre><code class="lang-javascript">Router.routes[&#39;post.show&#39;]
</code></pre>
<p>But we can also use the route name in the <code>Router.go</code> method like this:</p>
<pre><code class="lang-javascript">Router.go(&#39;post.show&#39;);
</code></pre>
<p>Now that we&#39;re using named routes in <code>Router.go</code> you can also pass a parameters
object, query and hash fragment options.</p>
<pre><code class="lang-javascript">Router.go(&#39;post.show&#39;, {_id: 1}, {query: &#39;q=s&#39;, hash: &#39;hashFrag&#39;});
</code></pre>
<p>The above JavaScript will navigate to this url:</p>
<pre><code class="lang-handlebars">/post/1?q=s#hashFrag
</code></pre>
<h3 id="getting-the-current-route">Getting the Current Route</h3>
<p>You can access the current route&#39;s name through the current controller with:</p>
<pre><code class="lang-javascript">Router.current().route.getName()
</code></pre>
<h2 id="template-lookup">Template Lookup</h2>
<p>If you don&#39;t explicitly set a template option on your route, and you don&#39;t
explicity render a template name, the router will try to automatically render a
template based on the name of the route. By default the router will look for the
class case name of the template.</p>
<p>For example, if you have a route defined like this:</p>
<pre><code class="lang-javascript">Router.route(&#39;/items/:_id&#39;, {name: &#39;items.show&#39;});
</code></pre>
<p>The router will by default look for a template named <code>ItemsShow</code> with capital
letters for each word and punctuation removed. If you would like to customize
this behavior you can set your own converter function. For example, let&#39;s say
you don&#39;t want any conversion. You can set the converter function like this:</p>
<pre><code class="lang-javascript">Router.setTemplateNameConverter(function (str) { return str; });
</code></pre>
<h2 id="path-and-link-template-helpers">Path and Link Template Helpers</h2>
<h3 id="pathfor">pathFor</h3>
<p>There are a few template helpers we can use to create links based on routes.
First, we can use the <code>{{pathFor}}</code> helper to generate a path for a given named
route. Given the <code>post.show</code> route we created above we can create a link like
this:</p>
<pre><code class="lang-handlebars">{{#with post}}
  &lt;a href=&quot;{{pathFor route=&#39;post.show&#39;}}&quot;&gt;Post Show&lt;/a&gt;
{{/with}}
</code></pre>
<p>Assuming we have a post with an id of &quot;1&quot;, the above snippet is equivalent to:</p>
<pre><code class="lang-handlebars">&lt;a href=&quot;/posts/1&quot;&gt;Post Show&lt;/a&gt;
</code></pre>
<p>We can pass <code>data</code>, <code>query</code> and <code>hash</code> options to the pathFor helper.</p>
<pre><code class="lang-handlebars">&lt;a href=&quot;{{pathFor route=&#39;post.show&#39; data=getPost query=&#39;q=s&#39; hash=&#39;frag&#39;}}&quot;&gt;Post Show&lt;/a&gt;
</code></pre>
<p>The data object will be interpolated onto the route parameters. The query and
hash arguments will be added to the href as a query string and hash fragment.
Let&#39;s say our data object looks like this:</p>
<pre><code class="lang-javascript">data = { _id: 1 };
</code></pre>
<p>The above <code>pathFor</code> expression will result in a link that looks like this:</p>
<pre><code class="lang-handlebars">&lt;a href=&quot;/post/1?q=s#frag&quot;&gt;Post Show&lt;/a&gt;
</code></pre>
<p>The benefit of using the <code>pathFor</code> helper is that we don&#39;t need to keep hard
coded <code>href</code> attributes all over the application.</p>
<h3 id="urlfor">urlFor</h3>
<p>While the <code>pathFor</code> helper generates a path for the given route, <code>urlFor</code> will
generate a fully qualified url. For example, <code>pathFor</code> might generate a path
that looks like <code>/posts/1</code> but <code>urlFor</code> would generate
<code>http://mysite.com/posts/1</code>.</p>
<h3 id="linkto">linkTo</h3>
<p>The <code>linkTo</code> helper automatically generates the html for an anchor tag along
with the route path for the given route, parameters, hash and query. You can
even provide a block of content to be used inside the link.</p>
<pre><code class="lang-handlebars">{{#linkTo route=&quot;post.show&quot; data=getData query=&quot;q=s&quot; hash=&quot;hashFrag&quot; class=&quot;my-cls&quot;}}
  &lt;span style=&quot;color: orange;&quot;&gt;
    Post Show
  &lt;/span&gt;
{{/linkTo}}
</code></pre>
<p>The expression above will be transformed into html that looks like this:</p>
<pre><code class="lang-handlebars">&lt;a href=&quot;/posts/1?q=s#hashFrag&quot; class=&quot;my-cls&quot;&gt;
  &lt;span style=&quot;color: orange;&quot;&gt;
    Post Show
  &lt;/span&gt;
&lt;/a&gt;
</code></pre>
<h2 id="route-options">Route Options</h2>
<p>So far you&#39;ve seen a few options you can provide to routes like the <code>name</code>
option. There are a few other options and several ways to provide options to
routes.</p>
<h3 id="route-specific-options">Route Specific Options</h3>
<p>In this example we&#39;ll omit the route function and just provide an options
object. The options object will explain each of the possible options.</p>
<pre><code class="lang-javascript">Router.route(&#39;/post/:_id&#39;, {
  // The name of the route.
  // Used to reference the route in path helpers and to find a default template
  // for the route if none is provided in the &quot;template&quot; option. If no name is
  // provided, the router guesses a name based on the path &#39;/post/:_id&#39;
  name: &#39;post.show&#39;,

  // To support legacy versions of Iron.Router you can provide an explicit path
  // as an option, in case the first parameter is actually a route name.
  // However, it is recommended to provide the path as the first parameter of the
  // route function.
  path: &#39;/post/:_id&#39;,

  // If we want to provide a specific RouteController instead of an anonymous
  // one we can do that here. See the Route Controller section for more info.
  controller: &#39;CustomController&#39;,

  // If the template name is different from the route name you can specify it
  // explicitly here.
  template: &#39;Post&#39;,

  // A layout template to be used with this route.
  // If there is no layout provided, a default layout will
  // be used.
  layoutTemplate: &#39;ApplicationLayout&#39;,

  // A declarative way of providing templates for each yield region
  // in the layout
  yieldRegions: {
    &#39;MyAside&#39;: {to: &#39;aside&#39;},
    &#39;MyFooter&#39;: {to: &#39;footer&#39;}
  },

  // a place to put your subscriptions
  subscriptions: function() {
    this.subscribe(&#39;items&#39;);

    // add the subscription to the waitlist
    this.subscribe(&#39;item&#39;, this.params._id).wait();
  },

  // Subscriptions or other things we want to &quot;wait&quot; on. This also
  // automatically uses the loading hook. That&#39;s the only difference between
  // this option and the subscriptions option above.
  waitOn: function () {
    return Meteor.subscribe(&#39;post&#39;, this.params._id);
  },

  // A data function that can be used to automatically set the data context for
  // our layout. This function can also be used by hooks and plugins. For
  // example, the &quot;dataNotFound&quot; plugin calls this function to see if it
  // returns a null value, and if so, renders the not found template.
  data: function () {
    return Posts.findOne({_id: this.params._id});
  },

  // You can provide any of the hook options described below in the &quot;Using
  // Hooks&quot; section.
  onRun: function () {},
  onRerun: function () {},
  onBeforeAction: function () {},
  onAfterAction: function () {},
  onStop: function () {},

  // The same thing as providing a function as the second parameter. You can
  // also provide a string action name here which will be looked up on a Controller
  // when the route runs. More on Controllers later. Note, the action function
  // is optional. By default a route will render its template, layout and
  // regions automatically.
  // Example:
  //  action: &#39;myActionFunction&#39;
  action: function () {
    // render all templates and regions for this route
    this.render();
  }
});
</code></pre>
<h3 id="global-default-options">Global Default Options</h3>
<p>You can set any of the above options on the Router itself. These become default
options for all of our routes. To set default Router options use the <code>configure</code>
method.</p>
<pre><code class="lang-javascript">Router.configure({
  layoutTemplate: &#39;ApplicationLayout&#39;,

  template: &#39;DefaultTemplate&#39;

  // .
  // .
  // .
});
</code></pre>
<p>Options declared on the route will override these default Router options.</p>
<h2 id="subscriptions">Subscriptions</h2>
<p>Sometimes you want to wait on one or more subscriptions to be ready, or maybe
on the result of some other action. For example, you might want to show a
loading template while waiting for subscription data.</p>
<h3 id="wait-and-ready">Wait and Ready</h3>
<p>You can use the <code>wait</code> method to add a subscription to the wait list. When you
call <code>this.ready()</code> it returns true if all items in the wait list are ready.</p>
<pre><code class="lang-javascript">Router.route(&#39;/post/:_id&#39;, function () {
  // add the subscription handle to our waitlist
  this.wait(Meteor.subscribe(&#39;item&#39;, this.params._id));

  // this.ready() is true if all items in the wait list are ready

  if (this.ready()) {
    this.render();
  } else {
    this.render(&#39;Loading&#39;);
  }
});
</code></pre>
<p>An alternative way to write the above example is to call the <code>wait</code> method
on the subscription directly. In this case you&#39;ll call <code>this.subscribe</code> instead
of <code>Meteor.subscribe</code>.</p>
<pre><code class="lang-javascript">Router.route(&#39;/post/:_id&#39;, function () {
  this.subscribe(&#39;item&#39;, this.params._id).wait();

  if (this.ready()) {
    this.render();
  } else {
    this.render(&#39;Loading&#39;);
  }
});
</code></pre>
<h3 id="the-subscriptions-option">The subscriptions Option</h3>
<p>You can automatically take advantage of this functionality by using the <code>subscriptions</code> option to your route.</p>
<pre><code class="lang-javascript">Router.route(&#39;/post/:_id&#39;, {
  subscriptions: function() {
    // returning a subscription handle or an array of subscription handles
    // adds them to the wait list.
    return Meteor.subscribe(&#39;item&#39;, this.params._id);
  },

  action: function () {
    if (this.ready()) {
      this.render();
    } else {
      this.render(&#39;Loading&#39;);
    }
  }
});
</code></pre>
<p>Your <code>subscriptions</code> function can return a single subscription handle (the result of <code>Meteor.subscribe</code>) or an array of them. The subscription(s) will be used to drive the <code>.ready()</code> state. </p>
<p>You can also inherit subscriptions from the global router config or from a controller (see below).</p>
<h3 id="the-waiton-option">The waitOn Option</h3>
<p>Another alternative is to use <code>waitOn</code> instead of <code>subscribe</code>. This has the same effect but automatically short-circuits your route action and any before hooks (see below), and renders a <code>loadingTemplate</code> instead. You can specify that template on the route or the router itself:</p>
<pre><code class="lang-javascript">Router.route(&#39;/post/:_id&#39;, {
  // this template will be rendered until the subscriptions are ready
  loadingTemplate: &#39;loading&#39;,

  waitOn: function () {
    // return one handle, a function, or an array
    return Meteor.subscribe(&#39;post&#39;, this.params._id);
  },

  action: function () {
    this.render(&#39;myTemplate&#39;);
  }
});
</code></pre>
<h2 id="server-routing">Server Routing</h2>
<h3 id="creating-routes">Creating Routes</h3>
<p>So far you&#39;ve seen features mostly intended for the browser. But you can also
create server routes with full access to the NodeJS request and response
objects. To create a server route you provide the <code>where: &#39;server&#39;</code> option to
the route.</p>
<pre><code class="lang-javascript">Router.route(&#39;/download/:file&#39;, function () {
  // NodeJS request object
  var request = this.request;

  // NodeJS  response object
  var response = this.response;

  this.response.end(&#39;file download content\n&#39;);
}, {where: &#39;server&#39;});
</code></pre>
<h3 id="restful-routes">Restful Routes</h3>
<p>You can even create server-side restful routes which correspond to an http verb.
This is particularly useful if you&#39;re setting up a webhook for another service
to post data to.</p>
<pre><code class="lang-javascript">Router.route(&#39;/webhooks/stripe&#39;, { where: &#39;server&#39; })
  .get(function () {
    // GET /webhooks/stripe
  })
  .post(function () {
    // POST /webhooks/stripe
  })
  .put(function () {
    // PUT /webhooks/stripe
  })
</code></pre>
<h3 id="404s-and-client-vs-server-routes">404s and Client vs Server Routes</h3>
<p>When you initially navigate to your Meteor application&#39;s url, the server router
will see if there are any routes defined for that url, either on the server or
on the client. If no routes are found, the server will send a 404 http status
code to indicate no resource was found for the given url.</p>
<h2 id="plugins">Plugins</h2>
<p>Plugins are a way to reuse functionality in your router, either that you&#39;ve
built for your own applications, or from other package authors. There&#39;s even a
built-in plugin called &quot;dataNotFound&quot;.</p>
<p>To use a plugin just call the <code>plugin</code> method of Router and pass the name of the
plugin and any options for the plugin.</p>
<pre><code class="lang-javascript">Router.plugin(&#39;dataNotFound&#39;, {notFoundTemplate: &#39;notFound&#39;});
</code></pre>
<p>This out-of-box plugin will automatically render the template named &quot;notFound&quot; 
if the route&#39;s data is falsey (i.e. <code>! this.data()</code>).</p>
<h3 id="applying-plugins-to-specific-routes">Applying Plugins to Specific Routes</h3>
<p>You can apply a plugin to a specific route by passing an <code>except</code> or <code>only</code> option
to the respective plugin function. This is useful for server routes, where you
explicitly don&#39;t want to run plugins designed for the client.</p>
<pre><code class="lang-javascript">Router.plugin(&#39;dataNotFound&#39;, {
  notFoundTemplate: &#39;NotFound&#39;, 
  except: [&#39;server.route&#39;]
  // or only: [&#39;routeOne&#39;, &#39;routeTwo&#39;]
});
</code></pre>
<p>In the above example, the dataNotFound will be applied to all routes except the 
route named &#39;server.route&#39;.</p>
<h3 id="creating-plugins">Creating Plugins</h3>
<p>To create a plugin just put your function on the <code>Iron.Router.plugins</code> object
like this:</p>
<pre><code class="lang-javascript">Iron.Router.plugins.loading = function (router, options) {
  // this loading plugin just creates an onBeforeAction hook
  router.onBeforeAction(&#39;loading&#39;, options);
};
</code></pre>
<p>The plugin function will get called with the router instance and any options the
user passed.</p>
<p><em>Package authors are encouraged to create new plugins!</em></p>
<h2 id="hooks">Hooks</h2>
<h3 id="using-hooks">Using Hooks</h3>
<p>A hook is just a function. Hooks provide a way to plug into the process of
running a route, typically to customize rendering behavior or perform some
business logic.</p>
<p>In this example, our goal is to only render the template and regions for a route
if the user is logged in. We&#39;ll add a hook function using the <code>onBeforeAction</code>
method to tell the router we want this function to run before our route
function, or the &quot;action&quot; function.</p>
<pre><code class="lang-javascript">Router.onBeforeAction(function () {
  // all properties available in the route function
  // are also available here such as this.params

  if (!Meteor.userId()) {
    // if the user is not logged in, render the Login template
    this.render(&#39;Login&#39;);
  } else {
    // otherwise don&#39;t hold up the rest of hooks or our route/action function
    // from running
    this.next();
  }
});
</code></pre>
<p>Now let&#39;s say we have a route defined like this:</p>
<pre><code class="lang-javascript">Router.route(&#39;/admin&#39;, function () {
  this.render(&#39;AdminPage&#39;);
});
</code></pre>
<p>Our onBeforeAction hook function will run before our route function when the
user navigates to &quot;/admin&quot;. If the user is not logged in, the route function
will never get called and the <code>AdminPage</code> will not render to the page.</p>
<p>Hook functions and all functions that get run when dispatching to a route are
run in a <strong>reactive computation</strong>: they will rerun if any reactive data sources
invalidate the computation. In the above example, if <code>Meteor.user()</code> changes the
entire set of route functions will be run again.</p>
<h3 id="applying-hooks-to-specific-routes">Applying Hooks to Specific Routes</h3>
<p>You can apply a hook to a specific route by passing an <code>except</code> or <code>only</code> option
to the respective hook function.</p>
<pre><code class="lang-javascript">Router.onBeforeAction(myAdminHookFunction, {
  only: [&#39;admin&#39;]
  // or except: [&#39;routeOne&#39;, &#39;routeTwo&#39;]
});
</code></pre>
<p>In the above example, the myAdminHookFunction will only get applied to a route
named &#39;admin.&#39;</p>
<h3 id="using-the-iron-router-hooks-namespace">Using the Iron.Router.hooks Namespace</h3>
<p>Package authors can add hook functions to <code>Iron.Router.hooks</code> and users can
reference those hooks by string name.</p>
<pre><code class="lang-javascript">Iron.Router.hooks.customPackageHook = function () {
  console.log(&#39;hi&#39;);
  this.next();
};

Router.onBeforeAction(&#39;customPackageHook&#39;);
</code></pre>
<h3 id="available-hook-methods">Available Hook Methods</h3>
<ul>
<li><p><strong>onRun</strong>: Called when the route is first run. It is not called again if the
route reruns because of a computation invalidation. This makes it a good 
candidate for things like analytics where you want be sure the hook only runs once. Note that this hook <em>won&#39;t</em> run again if the route is reloaded via hot code push.</p>
</li>
<li><p><strong>onRerun</strong>: Called if the route reruns because its computation is
invalidated. Similarly to <code>onBeforeAction</code>, if you want to continue calling the next function, you
<em>must</em> call <code>this.next()</code>.</p>
</li>
<li><p><strong>onBeforeAction</strong>: Called before the route or &quot;action&quot; function is run. These
hooks behave specially. If you want to continue calling the next function you
<em>must</em> call <code>this.next()</code>. If you don&#39;t, downstream onBeforeAction hooks and
your action function will <em>not</em> be called.</p>
</li>
<li><p><strong>onAfterAction</strong>: Called after your route/action function has run or had a
chance to run. These hooks behave like normal hooks and you don&#39;t need to call
<code>this.next()</code> to move from one to the next.</p>
</li>
<li><p><strong>onStop</strong>: Called when the route is stopped, typically right before a new
route is run.</p>
</li>
</ul>
<h3 id="server-hooks-and-connect">Server Hooks and Connect</h3>
<p>On the server, the API signature for a <code>onBeforeAction</code> hook is identical to that of a <a href="https://github.com/senchalabs/connect">connect</a> middleware:</p>
<pre><code class="lang-javascript">Router.onBeforeAction(function(req, res, next) {
  // in here next() is equivalent to this.next();
}, {where: &#39;server&#39;});
</code></pre>
<p>This means you can attach any connect middleware you like on the server side using <code>Router.onBeforeAction()</code>. For convience, IR makes express&#39; <a href="https://github.com/expressjs/body-parser">body-parser</a> available at <code>Iron.Router.bodyParser</code>.</p>
<p>The Router attaches the JSON body parser automatically.</p>
<h2 id="route-controllers">Route Controllers</h2>
<p>An <code>Iron.RouteController</code> object is created when the Router handles a url
change. The <code>RouteController</code> gives us a place to store state as we run the
route, and persists until another route is run.</p>
<p>We&#39;ve been calling a few methods inside of our route functions like
<code>this.render()</code> and <code>this.layout()</code>. The <code>this</code> object inside of these functions
is actually an instance of a <code>RouteController</code>. If you&#39;re building a simple
application you probably don&#39;t need to worry about <code>RouteController</code>. But if
your application gets larger, using <code>RouteControllers</code> directly offers two key
benefits:</p>
<ul>
<li><strong>Inheritance</strong>: You can inherit from other RouteControllers to model your
application&#39;s behavior.</li>
<li><strong>Organization</strong>: You can begin to separate your route logic into
RouteController files instead of putting all of your complex business logic
into one big route file.</li>
</ul>
<h3 id="creating-route-controllers">Creating Route Controllers</h3>
<p>You can create a custom <code>RouteController</code> like this:</p>
<pre><code class="lang-javascript">PostController = RouteController.extend();
</code></pre>
<p>When you define a route, you can specify a controller to use, or the router will
try to find a controller automatically based on the name of the route.</p>
<pre><code class="lang-javascript">Router.route(&#39;/post/:_id&#39;, {
  name: &#39;post&#39;
});
</code></pre>
<p>The route defined above will automatically use the <code>PostController</code> using the
name of the route. We can tell the route to use a different controller by
providing a controller option.</p>
<pre><code class="lang-javascript">Router.route(&#39;/post/:_id&#39;, {
  name: &#39;post.show&#39;,
  controller: &#39;CustomController&#39;
});
</code></pre>
<p>We can use all of the same options from our routes on our <code>RouteControllers</code>.</p>
<pre><code class="lang-javascript">PostController = RouteController.extend({
  layoutTemplate: &#39;PostLayout&#39;,

  template: &#39;Post&#39;,

  waitOn: function () { return Meteor.subscribe(&#39;post&#39;, this.params._id); },

  data: function () { return Posts.findOne({_id: this.params._id}) },

  action: function () {
    this.render();
  }
});
</code></pre>
<p>We might have some options defined globally with <code>Router.configure</code>, some
options defined on the <code>Route</code> and some options defined on the
<code>RouteController</code>. Iron.Router looks up options in this order:</p>
<ol>
<li>Route</li>
<li>RouteController</li>
<li>Router</li>
</ol>
<h3 id="inheriting-from-route-controllers">Inheriting from Route Controllers</h3>
<p>RouteControllers can inherit from other RouteControllers. This enables some
interesting organization schemes for your application.</p>
<p>Let&#39;s say we have an <code>ApplicationController</code> which we want to use as the default
controller for all routes.</p>
<pre><code class="lang-javascript">ApplicationController = RouteController.extend({
  layoutTemplate: &#39;ApplicationLayout&#39;,

  onBeforeAction: function () {
    // do some login checks or other custom logic
    this.next();
  }
});

Router.configure({
  // this will be the default controller
  controller: &#39;ApplicationController&#39;
});

// now we have a route for posts
Router.route(&#39;/posts/:_id&#39;, {
  name: &#39;post&#39;
});

// inherit from `ApplicationController` and override any
// behavior you&#39;d like.
PostController = ApplicationController.extend({
  layoutTemplate: &#39;PostLayout&#39;
});
</code></pre>
<p><em>NOTE: This is currently a bit tricky with Meteor since you can&#39;t precisely
control file load order. You need to make sure parent RouteControllers are
evaluated before child RouteControllers.</em></p>
<h3 id="accessing-the-current-route-controller">Accessing the Current Route Controller</h3>
<p>There are two ways to access the current <code>RouteController</code>.</p>
<p>If you&#39;re on the client, you can use the <code>Router.current()</code> method. This will
reactively return the current instance of a <code>RouteController</code>. Keep in mind this
value could be <code>null</code> if no route has run yet.</p>
<p>You can also access the current <code>RouteController</code> from inside your template
helpers by using the <code>Iron.controller()</code> method.</p>
<pre><code class="lang-javascript">Router.route(&#39;/posts&#39;, function () {
  this.render(&#39;Posts&#39;);
});
</code></pre>
<p>This route will render the <code>Posts</code> template defined below.</p>
<pre><code class="lang-handlebars">&lt;template name=&quot;Posts&quot;&gt;
  Posts
&lt;/template&gt;
</code></pre>
<p>Now let&#39;s say we want to access the current controller from a template helper
defined on the <code>Posts</code> template.</p>
<pre><code class="lang-javascript">Template.Posts.helpers({
  myHelper: function () {
    var controller = Iron.controller();

    // now we can get properties and call methods on the controller
  }
});
</code></pre>
<h3 id="setting-reactive-state-variables">Setting Reactive State Variables</h3>
<p>You can set reactive state variables on controllers using the <code>set</code> method on
the controller&#39;s <a href="https://atmospherejs.com/meteor/reactive-dict">ReactiveDict</a> <code>state</code>.</p>
<p>Let&#39;s say we want to store the post <code>_id</code> in a reactive variable:</p>
<pre><code class="lang-javascript">Router.route(&#39;/posts/:_id&#39;, {name: &#39;post&#39;});

PostController = RouteController.extend({
  action: function () {
    // set the reactive state variable &quot;postId&quot; with a value
    // of the id from our url
    this.state.set(&#39;postId&#39;, this.params._id);
    this.render();
  }
});
</code></pre>
<h3 id="getting-reactive-state-variables">Getting Reactive State Variables</h3>
<p>You can get a reactive variable value by calling <code>this.state.get(&quot;key&quot;)</code> on the
<code>RouteController</code>. Using the example above, let&#39;s grab the value of <code>postId</code>
from a template helper.</p>
<pre><code class="lang-javascript">Template.Post.helpers({
  postId: function () {
    var controller = Iron.controller();

    // reactively return the value of postId
    return controller.state.get(&#39;postId&#39;);
  }
});
</code></pre>
<h2 id="custom-router-rendering">Custom Router Rendering</h2>
<p>So far we&#39;ve been letting the Router render itself to the page automatically.
But you can also control precisely where the Router renders itself by using a
global helper method.</p>
<pre><code class="lang-handlebars">&lt;body&gt;
  &lt;h1&gt;Some App Html&lt;/h1&gt;
  &lt;div class=&quot;container&quot;&gt;
    {{! Render the router into this div instead of the body}}
    {{&gt; Router}}
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h2 id="legacy-browser-support">Legacy Browser Support</h2>
<p>Legacy browsers do not support the HTML5 <code>pushState</code> and <code>history</code> features
required for normal client side browsing with the <code>Router</code>. To solve this
problem, the <code>Router</code> can fall back to using hash fragments in the url.
Actually, under the hood, <code>iron-router</code> uses a package called <code>iron-location</code>
which handles all of this. It works similarly to the <code>History.js</code> project but
works seamlessly.</p>
<p>This functionality is automatically enabled for <strong>IE8</strong> and <strong>IE9</strong>. If you want
to enable it manually to play around you can configure <code>Iron.Location</code> like
this:</p>
<pre><code class="lang-javascript">Iron.Location.configure({useHashPaths: true});
</code></pre>
<p>Even though the url will appear differently in the browser when using this mode,
the url, query, hash and parameters will look like their regular values inside
of <code>RouteController</code> functions. Here are a few examples of how urls will be
translated.</p>
<pre><code class="lang-bash">http://localhost:3000/items/5?q=s#hashFrag
</code></pre>
<p>The url above would be transformed to the url below in your browser.</p>
<pre><code class="lang-bash">http://localhost:3000/#/items/5?q=s&amp;__hash__=hashFrag
</code></pre>
<p>But in your <code>RouteController</code> functions you can access the url, query and hash
values just like you have before.</p>
<pre><code class="lang-javascript">Router.route(&#39;/items/:_id&#39;, function () {
  var id = this.params._id; // &quot;5&quot;
  var query = this.params.query; // {q: &quot;s&quot;}
  var hash = this.params.hash; // &quot;hashFrag&quot;
});
</code></pre>
<p><strong>NOTE: Please let us know if you can help test support on other browsers!</strong></p>

      </div>
    </div>
    <script src="javascripts/prism.js"></script>
  </body>
</html>
